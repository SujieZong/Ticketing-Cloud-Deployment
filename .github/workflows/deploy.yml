name: Deploy Ticketing System

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Deployment action"
        required: true
        type: choice
        default: "full-deployment"
        options:
          - full-deployment
          - infrastructure-only
          - services-only
          - destroy-infrastructure
          - force-cleanup
      import_existing:
        description: "Import existing cloud resources into TF state (use only for takeover/recovery)"
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: us-west-2
  TF_VERSION: 1.6.0

jobs:
  build:
    name: Build Java Services
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'services-only' || github.event.inputs.action == 'full-deployment'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven
      - name: Build Services
        run: |
          cd PurchaseService && mvn clean package -DskipTests
          cd ../QueryService && mvn clean package -DskipTests
          cd ../MessagePersistenceService && mvn clean package -DskipTests
      - uses: actions/upload-artifact@v4
        with:
          name: service-jars
          path: |
            PurchaseService/target/*.jar
            QueryService/target/*.jar
            MessagePersistenceService/target/*.jar
          retention-days: 1

  force-cleanup:
    name: Force Cleanup AWS
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'force-cleanup'
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Cleanup
        run: |
          chmod +x ./config/scripts/cleanup-aws-resources.sh
          ./config/scripts/cleanup-aws-resources.sh
          sleep 180

  terraform:
    name: Terraform Infrastructure
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'infrastructure-only' || github.event.inputs.action == 'full-deployment' || github.event.inputs.action == 'destroy-infrastructure'
    outputs:
      alb_dns: ${{ steps.tf_out.outputs.alb_dns }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      - name: Restore State
        if: github.event.inputs.action == 'destroy-infrastructure'
        uses: actions/cache/restore@v3
        with:
          path: |
            config/terraform/terraform.tfstate
            config/terraform/terraform.tfstate.backup
            config/terraform/.terraform
          key: terraform-state-${{ github.ref_name }}
      - name: Create tfvars
        working-directory: ./config/terraform
        run: |
          # Get current AWS account ID
          ACCT=$(aws sts get-caller-identity --query Account --output text)
          
          # Create terraform.tfvars from template
          cp terraform.tfvars.template terraform.tfvars
          
          # Replace placeholders with actual values
          sed -i.bak "s/YOUR_AWS_ACCOUNT_ID/$ACCT/g" terraform.tfvars
          sed -i.bak "s/aws_region         = \".*\"/aws_region         = \"${{ env.AWS_REGION }}\"/" terraform.tfvars
          sed -i.bak "s/YOUR_IP_ADDRESS/${{ secrets.ALLOWED_IP }}/g" terraform.tfvars
          
          # For infrastructure-only, don't create ECS services
          if [[ "${{ github.event.inputs.action }}" == "infrastructure-only" ]]; then
            echo "" >> terraform.tfvars
            echo "create_ecs_services = false" >> terraform.tfvars
          else
            echo "" >> terraform.tfvars
            echo "create_ecs_services = true" >> terraform.tfvars
          fi
          
          # AWS credentials are already configured via aws-actions/configure-aws-credentials
          # So we can remove the credential lines from tfvars
          sed -i.bak '/aws_access_key_id/d' terraform.tfvars
          sed -i.bak '/aws_secret_access_key/d' terraform.tfvars
          sed -i.bak '/aws_session_token/d' terraform.tfvars
          
          echo "Generated terraform.tfvars:"
          cat terraform.tfvars
      - name: Init
        working-directory: ./config/terraform
        run: terraform init -upgrade
      - name: Import Resources
        if: github.event.inputs.action != 'destroy-infrastructure' && github.event.inputs.import_existing == 'true'
        working-directory: ./config/terraform
        continue-on-error: true
        run: |
          REGION=${{ env.AWS_REGION }}
          imp() { 
            echo "Importing: $1 <- $2"
            terraform import "$1" "$2" 2>&1 | grep -v "Resource already managed" || true
          }

          imp 'module.ecr["purchase-service"].aws_ecr_repository.this' 'purchase-service'
          imp 'module.ecr["query-service"].aws_ecr_repository.this' 'query-service'
          imp 'module.ecr["message-persistence-service"].aws_ecr_repository.this' 'message-persistence-service'

          ALB=$(aws elbv2 describe-load-balancers --region $REGION --query "LoadBalancers[?LoadBalancerName=='ticketing-alb'].LoadBalancerArn" --output text 2>/dev/null || echo "")
          [ -n "$ALB" ] && imp 'module.shared_alb.aws_lb.shared' "$ALB"

          for svc in purchase query message-persistence; do
            TG=$(aws elbv2 describe-target-groups --region $REGION --query "TargetGroups[?TargetGroupName=='${svc}-service-tg'].TargetGroupArn" --output text 2>/dev/null || echo "")
            [ -n "$TG" ] && imp "module.shared_alb.aws_lb_target_group.services[\"${svc}-service\"]" "$TG"
          done

          ALB_SG=$(aws ec2 describe-security-groups --region $REGION --filters "Name=group-name,Values=ticketing-alb-sg" --query "SecurityGroups[0].GroupId" --output text 2>/dev/null || echo "")
          [ -n "$ALB_SG" ] && [ "$ALB_SG" != "None" ] && imp 'module.network.aws_security_group.alb_sg' "$ALB_SG"

          ECS_SG=$(aws ec2 describe-security-groups --region $REGION --filters "Name=group-name,Values=ticketing-ecs-sg" --query "SecurityGroups[0].GroupId" --output text 2>/dev/null || echo "")
          [ -n "$ECS_SG" ] && [ "$ECS_SG" != "None" ] && imp 'module.network.aws_security_group.this' "$ECS_SG"

          RDS_SG=$(aws ec2 describe-security-groups --region $REGION --filters "Name=group-name,Values=ticketing-rds-sg" --query "SecurityGroups[0].GroupId" --output text 2>/dev/null || echo "")
          [ -n "$RDS_SG" ] && [ "$RDS_SG" != "None" ] && imp 'module.network.aws_security_group.rds_sg' "$RDS_SG"

          REDIS_SG=$(aws ec2 describe-security-groups --region $REGION --filters "Name=group-name,Values=ticketing-redis-sg" --query "SecurityGroups[0].GroupId" --output text 2>/dev/null || echo "")
          [ -n "$REDIS_SG" ] && [ "$REDIS_SG" != "None" ] && imp 'module.elasticache.aws_security_group.redis_sg' "$REDIS_SG"

          imp 'module.rds.aws_rds_cluster.this' 'ticketing-aurora'
          imp 'module.rds.aws_rds_cluster_instance.writer' 'ticketing-aurora-writer'
          imp 'module.rds.aws_rds_cluster_instance.readers[0]' 'ticketing-aurora-reader-1'
          imp 'module.rds.aws_db_subnet_group.default' 'ticketing-aurora-subnet-group'
          imp 'module.rds.aws_rds_cluster_parameter_group.this' 'ticketing-mysql-params'

          imp 'module.elasticache.aws_elasticache_subnet_group.this' 'ticketing-cache-subnet-group'
          imp 'module.elasticache.aws_elasticache_parameter_group.this' 'ticketing-redis-params'
          imp 'module.elasticache.aws_elasticache_replication_group.this' 'ticketing-redis'

          for svc in purchase query message-persistence; do
            imp "module.logging[\"${svc}-service\"].aws_cloudwatch_log_group.this" "/ecs/${svc}-service"
          done

          imp 'module.elasticache.aws_secretsmanager_secret.redis' 'ticketing-redis-credentials'
          imp 'module.rds.aws_secretsmanager_secret.db' 'ticketing-db-credentials'

          POLICY=$(aws iam list-policies --query "Policies[?PolicyName=='ticketing-message-messaging-access'].Arn" --output text 2>/dev/null || echo "")
          [ -n "$POLICY" ] && imp 'module.messaging.aws_iam_policy.messaging_access' "$POLICY"
      - name: Plan
        if: github.event.inputs.action != 'destroy-infrastructure'
        working-directory: ./config/terraform
        run: terraform plan -no-color
      - name: Apply
        if: github.event.inputs.action != 'destroy-infrastructure'
        working-directory: ./config/terraform
        run: terraform apply -auto-approve
      - name: Destroy
        if: github.event.inputs.action == 'destroy-infrastructure'
        working-directory: ./config/terraform
        continue-on-error: true
        run: terraform destroy -auto-approve || (chmod +x ../../config/scripts/cleanup-aws-resources.sh && ../../config/scripts/cleanup-aws-resources.sh)
      - name: Save State
        if: github.event.inputs.action != 'destroy-infrastructure' && success()
        uses: actions/cache/save@v3
        with:
          path: |
            config/terraform/terraform.tfstate
            config/terraform/terraform.tfstate.backup
            config/terraform/.terraform
          key: terraform-state-${{ github.ref_name }}-${{ github.run_number }}
      - name: Outputs
        if: github.event.inputs.action != 'destroy-infrastructure'
        id: tf_out
        working-directory: ./config/terraform
        run: |
          ALB=$(terraform output -raw alb_dns_name 2>/dev/null || echo "pending")
          echo "alb_dns=$ALB" >> $GITHUB_OUTPUT

  deploy-services:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: [build, terraform]
    if: always() && (needs.build.result == 'success' || needs.build.result == 'skipped') && needs.terraform.result == 'success' && (github.event.inputs.action == 'services-only' || github.event.inputs.action == 'full-deployment')
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        if: needs.build.result == 'success'
        with:
          name: service-jars
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}
      - uses: aws-actions/amazon-ecr-login@v2
        id: ecr
      - uses: docker/setup-buildx-action@v3
      - name: Build & Push
        env:
          ECR: ${{ steps.ecr.outputs.registry }}
          TAG: ${{ github.sha }}
        run: |
          docker buildx build --platform linux/amd64 --push -t $ECR/purchase-service:$TAG -t $ECR/purchase-service:latest ./PurchaseService
          docker buildx build --platform linux/amd64 --push -t $ECR/query-service:$TAG -t $ECR/query-service:latest ./QueryService
          docker buildx build --platform linux/amd64 --push -t $ECR/message-persistence-service:$TAG -t $ECR/message-persistence-service:latest ./MessagePersistenceService
      - name: Update ECS
        run: |
          for svc in purchase query message-persistence; do
            aws ecs update-service --cluster ${svc}-service-cluster --service ${svc}-service --force-new-deployment --region ${{ env.AWS_REGION }} 2>&1 || true
          done
          sleep 120
